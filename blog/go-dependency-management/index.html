<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" /><title>Go Dependency Management - Muhammed Uluyol</title><meta name="HandheldFriendly" content="True" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet" type="text/css">
<link href="/css/libertine/font.css" rel="stylesheet">
<link href="/css/normalize.css" rel="stylesheet" media="screen">
<link href="/css/main.css" rel="stylesheet" media="screen">


</head>
<body class="nav-closed">
	<div id="main">
		<div class="nav">
	<a href="/">Home</a>
	<a href="https://github.com/uluyol/">GitHub</a>
	<a href="/blog/">Blog</a>
	
	<a href="/blog/index.xml">Feed</a>
</div>


		<div class="title-text">
			<h1>Go Dependency Management</h1>
			<time class="post-date" datetime="2016-06-04">Apr 6, 2016</time>
		</div>

		<div class="content">
			

<p>Different languages have different ways of managing dependencies. C/C++ don&rsquo;t do any of this for you. Newer languages have tools like pip, npm, maven, etc. to handle dependencies.</p>

<p>Go packages are typically referred to through URLs (e.g. github.com/coreos/etcd/clientv3). This is nice because it&rsquo;s completely decentralized. However, Go doesn&rsquo;t have any notion of package versions. This means that the go tool will always fetch the git HEAD of the repository. The recommendation from the Go team to solve this has been to vendor dependencies (i.e. pull the code into your source tree).</p>

<h2 id="vendoring">Vendoring</h2>

<p>Vendoring is useful because it allows your code to build even if the original code is taken offline. Go&rsquo;s initial approach to vendoring was to rewrite import paths. If I was developing package example.com/foo and I needed to import golang.org/x/net/context, I could copy this into example.com/foo/third_party/golang.org/x/net/context. These import paths are long and might require making changes to libraries that you depend on.</p>

<p>The go tool now has explicit support for vendor directories. When package a/b/c wants to import d/e/f, if there is a package a/b/c/vendor/d/e/f, it will use that copy (alternatively, one in a/b/vendor or anywhere higher up if that doesn&rsquo;t exist).</p>

<p>With this, dependency management is solved right? Just vendor everything and dependencies can be solved by third party tooling while everything still stays go get compatible. Not quite.</p>

<h2 id="problems">Problems</h2>

<p>First, libraries should never vendor any dependencies that aren&rsquo;t just used internally. For instance, if my library has a function that takes a golang.org/x/net/context.Context argument, it should not vendor that package. On the other hand, if I have a decimal number processing package that uses math/big.Float internally and never exposes it, I can vendor the math/big package.</p>

<p>The second issue is with repositories that store both libraries and commands. The canonical way of managing this is to have a cmd subdirectory. This is where the problems start. If I have a Z/client library which imports golang.org/x/net/context.Context and have vendored the context library in Z/cmd/vendor/golang.org/x/net/context, building Z/cmd/zclient will have two, distinct copies of the context library built:</p>

<ul>
<li>Z/client will build against golang.org/x/net/context</li>
<li>Z/cmd/zclient will build against Z/cmd/vendor/golang.org/x/net/context</li>
</ul>

<p>In the case of context, this should be benign because the interface isn&rsquo;t changing, but with other code, this may introduce issues. One solution to this problem is to vendor Z/client in Z/cmd/vendor/Z/client.</p>

<p>I don&rsquo;t find this satisfactory. It works, but it&rsquo;s really ugly. I would like the go tool to be replaced by something project-based like <a href="https://getgb.io/">gb</a>. Unfortunately, gb isn&rsquo;t well-suited to developing libraries. While it&rsquo;s not the end of the world, bouncing between the go tool and gb isn&rsquo;t ideal. Until now, I&rsquo;ve lived with the go tool without complaining much, but after seeing the above vendoring issue, I really think that it&rsquo;s time to use something else<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>.</p>

<p><strong>Update:</strong> After some more thought, I&rsquo;m not convinced that a project-based approach is the best either. Workspaces have the advantage that you can make automated changes across all of the code at once.</p>

<p><small>
</small></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">I say this as someone who is a big fan of how the Go team has been managing most of the development of the Go language and implementation.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
</ol>
</div>

		</div>
	</div>
</body>
</html>
